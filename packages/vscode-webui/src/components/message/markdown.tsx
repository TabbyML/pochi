import { CustomHtmlTags } from "@/lib/constants";
import { cn } from "@/lib/utils";
import { isKnownProgrammingLanguage } from "@/lib/utils/languages";
import { isVSCodeEnvironment, vscodeHost } from "@/lib/vscode";
import {
  type DetailedHTMLProps,
  type HTMLAttributes,
  type JSX,
  memo,
  useCallback,
  useContext,
  useMemo,
} from "react";
import rehypeSanitize, { defaultSchema } from "rehype-sanitize";
import { ControlsContext, Streamdown } from "streamdown";
import { FileBadge } from "../tool-invocation/file-badge";
import { CodeBlock } from "./code-block";
import { customStripTagsPlugin } from "./custom-strip-tags-plugin";
import "./markdown.css";
import { useReplaceJobIdsInContent } from "@/features/chat";
import type { ExtraProps, Options } from "react-markdown";

const mathSanitizeConfig = {
  // Custom schema to allow math-related elements
  tagNames: [
    "math",
    "mi",
    "mn",
    "mo",
    "ms",
    "mtext",
    "mspace",
    "menclose",
    "merror",
    "mfenced",
    "mfrac",
    "mfraction",
    "mglyph",
    "mi",
    "mlabeledtr",
    "mmultiscripts",
    "mn",
    "mo",
    "mover",
    "mpadded",
    "mphantom",
    "mroot",
    "mrow",
    "ms",
    "mspace",
    "msqrt",
    "mstyle",
    "msub",
    "msubsup",
    "msup",
    "mtable",
    "mtd",
    "mtext",
    "mtr",
    "munder",
    "munderover",
    "semantics",
    "annotation",
    "annotation-xml",
  ], // Add any other tags generated by your math plugin
  attributes: {
    "*": ["className", "style"], // Allow common attributes
    // Add specific attributes needed for math rendering, e.g.,
    span: ["aria-hidden"],
    div: ["aria-hidden"],
    svg: ["width", "height", "viewBox", "aria-hidden"],
    path: ["d", "fill"],
  },
};

interface InlineCodeComponentProps {
  className?: string;
  children?: React.ReactNode;
}

function InlineCodeComponent({
  className,
  children,
}: InlineCodeComponentProps) {
  if (typeof children === "string") {
    // have file extension like `file.txt`
    const isFilePath = (text: string): boolean => {
      return (
        !text.includes("://") &&
        // file name should not be empty, e.g. .ts is not a valid file path
        /.+\.[a-z0-9]+$/i.test(text) &&
        isKnownProgrammingLanguage(text)
      );
    };

    // have folder path like `folder/` or `folder/subfolder`
    const isFolderPath = (text: string): boolean => {
      return (
        !text.startsWith("@") &&
        !text.includes("://") &&
        !/\s/.test(text) &&
        (text.includes("/") || text.includes("\\")) &&
        !text.startsWith("\\")
      );
    };

    // children may be file path, folder path, symbol or normal text, we need to handle each case
    if (isFilePath(children)) {
      const pathSeparatorCount = (children.match(/[\/\\]/g) || []).length;
      return (
        <FileBadge
          path={children}
          fallbackGlobPattern={
            // glob pattern use `/` as path separator even on windows; when applied, glob pattern will match paths with both `/` and `\`
            pathSeparatorCount >= 2 ? `**/${children}` : undefined
          }
        />
      );
    }
    if (isFolderPath(children)) {
      return <FileBadge path={children} isDirectory={true} />;
    }
  }

  return <code className={cn("inline-code", className)}>{children}</code>;
}

interface BlockCodeComponentProps {
  className?: string;
  children?: React.ReactNode;
  language?: string;
}

const shouldShowControls = (
  config: boolean | { table?: boolean; code?: boolean; mermaid?: boolean },
  type: "table" | "code" | "mermaid",
) => {
  if (typeof config === "boolean") {
    return config;
  }

  return config[type] !== false;
};

function BlockCodeComponent({
  className,
  children,
  language = "",
}: BlockCodeComponentProps) {
  const controlsConfig = useContext(ControlsContext);

  let value = String(children).replace(/\n$/, "");
  if (!shouldShowControls(controlsConfig, "code") && value.length > 512) {
    value = `... ${language} code omitted ( ${value.length} bytes ) ...`;
  }
  return (
    <CodeBlock
      language={language}
      value={value}
      className={cn("max-h-none", className)}
      isMinimalView={!shouldShowControls(controlsConfig, "code")}
    />
  );
}

interface CodeComponentProps {
  className?: string;
  children?: React.ReactNode;
  node?: {
    position?: {
      start: { line: number };
      end: { line: number };
    };
  };
}

function CodeComponent({ className, children, node }: CodeComponentProps) {
  if (children && Array.isArray(children) && children.length) {
    if (children[0] === "▍") {
      return <span className="mt-1 animate-pulse cursor-default">▍</span>;
    }

    children[0] = (children[0] as string).replace("`▍`", "▍");
  }

  const match = /language-(\w+)/.exec(className || "");

  const isInline =
    node?.position && node.position.start.line === node.position.end.line;

  if (isInline) {
    return (
      <InlineCodeComponent className={className}>
        {children}
      </InlineCodeComponent>
    );
  }

  return (
    <BlockCodeComponent className={className} language={match?.[1]}>
      {children}
    </BlockCodeComponent>
  );
}

interface MessageMarkdownProps {
  children: string;
  className?: string;
  isMinimalView?: boolean;
  previewImageLink?: boolean;
}

interface FileComponentProps {
  children: string;
}

interface WorkflowComponentProps {
  id: string;
  path: string;
  children: string;
}

function escapeMarkdown(text: string): string {
  return text.replace(/[\\`*_{}\[\]()#+\-.!|<]/g, "\\$&");
}

/**
 * escape markdown content in certain tag, like <file>content to escape</file>
 */
function escapeMarkdownTag(tag: string): (text: string) => string {
  return (text: string): string => {
    const regex = new RegExp(`<${tag}([^>]*?)>(.*?)</${tag}>`, "gs");
    return text.replace(regex, (_match, attr, content) => {
      const escapedContent = escapeMarkdown(content);
      return `<${tag}${attr}>${escapedContent}</${tag}>`;
    });
  };
}

function isImageLink(url: string): boolean {
  return /\.(jpeg|jpg|gif|png|bmp|webp|svg)(?=[?#]|$)/i.test(url);
}

type MarkdownPoint = { line?: number; column?: number };
type MarkdownPosition = { start?: MarkdownPoint; end?: MarkdownPoint };
type MarkdownNode = {
  position?: MarkdownPosition;
  properties?: { className?: string };
};

function sameNodePosition(prev?: MarkdownNode, next?: MarkdownNode): boolean {
  if (!(prev?.position || next?.position)) {
    return true;
  }
  if (!(prev?.position && next?.position)) {
    return false;
  }

  const prevStart = prev.position.start;
  const nextStart = next.position.start;
  const prevEnd = prev.position.end;
  const nextEnd = next.position.end;

  return (
    prevStart?.line === nextStart?.line &&
    prevStart?.column === nextStart?.column &&
    prevEnd?.line === nextEnd?.line &&
    prevEnd?.column === nextEnd?.column
  );
}

function sameClassAndNode(
  prev: { className?: string; node?: MarkdownNode },
  next: { className?: string; node?: MarkdownNode },
) {
  return (
    prev.className === next.className && sameNodePosition(prev.node, next.node)
  );
}

const MemoCode = memo<
  DetailedHTMLProps<HTMLAttributes<HTMLElement>, HTMLElement> &
    ExtraProps & { isMinimalView?: boolean }
>(
  CodeComponent,
  (p, n) => p.className === n.className && sameNodePosition(p.node, n.node),
);
MemoCode.displayName = "MarkdownCode";

type WithNode<T> = T & {
  node?: MarkdownNode;
  children?: React.ReactNode;
  className?: string;
};
type LiProps = WithNode<JSX.IntrinsicElements["li"]>;

const MemoLi = memo<LiProps>(
  ({ children, className, ...props }: LiProps) => (
    <li className={className} data-streamdown="list-item" {...props}>
      {children}
    </li>
  ),
  (p, n) => p.className === n.className && sameNodePosition(p.node, n.node),
);
MemoLi.displayName = "MarkdownLi";

type UlProps = WithNode<JSX.IntrinsicElements["ul"]>;
const MemoUl = memo<UlProps>(
  ({ children, className, ...props }: UlProps) => (
    <ul
      className={cn("list-outside list-disc whitespace-normal", className)}
      data-streamdown="unordered-list"
      {...props}
    >
      {children}
    </ul>
  ),
  (p, n) => sameClassAndNode(p, n),
);
MemoUl.displayName = "MarkdownUl";

type OlProps = WithNode<JSX.IntrinsicElements["ol"]>;
const MemoOl = memo<OlProps>(
  ({ children, className, ...props }: OlProps) => (
    <ol
      className={cn("list-outside list-decimal whitespace-normal", className)}
      data-streamdown="ordered-list"
      {...props}
    >
      {children}
    </ol>
  ),
  (p, n) => sameClassAndNode(p, n),
);
MemoOl.displayName = "MarkdownOl";

export function MessageMarkdown({
  children,
  className,
  isMinimalView,
  previewImageLink,
}: MessageMarkdownProps) {
  const replaceJobIdsInContent = useReplaceJobIdsInContent();
  const processedChildren = useMemo(() => {
    let result = children;
    for (const tag of CustomHtmlTags) {
      const escapeTagContent = escapeMarkdownTag(tag);
      result = escapeTagContent(result);
    }

    return replaceJobIdsInContent(result);
  }, [children, replaceJobIdsInContent]);

  const components: Options["components"] = useMemo(() => {
    return {
      file: (props: FileComponentProps) => {
        const { children } = props;
        const filepath = String(children);
        return <FileBadge path={filepath} />;
      },
      workflow: (props: WorkflowComponentProps) => {
        const { id, path } = props;
        return (
          <FileBadge label={id.replaceAll("user-content-", "/")} path={path} />
        );
      },
      "custom-agent": (props: WorkflowComponentProps) => {
        const { id, path } = props;
        return (
          <FileBadge label={id.replaceAll("user-content-", "/")} path={path} />
        );
      },
      code: (props) => <MemoCode {...props} />,
      a({ href, children, ...props }) {
        const openLink = useCallback(() => {
          href && isVSCodeEnvironment()
            ? vscodeHost.openExternal(href)
            : window.open(href, "_blank");
        }, [href]);

        if (previewImageLink && href && isImageLink(href)) {
          return (
            <img
              src={href}
              alt={String(children)}
              className="max-w-full cursor-pointer rounded"
              onClick={openLink}
            />
          );
        }

        // biome-ignore lint/suspicious/noExplicitAny: props from react-markdown contains a `node` property that is not a valid DOM attribute
        const { node, ...rest } = props as any;
        return (
          <button
            type="button"
            className="inline cursor-pointer appearance-none border-none bg-transparent p-0 text-left font-sans underline"
            onClick={openLink}
            {...rest}
          >
            {children}
          </button>
        );
      },
      hr() {
        return null;
      },
      p: ({ children }) => (
        <p className="whitespace-pre-wrap leading-relaxed">{children}</p>
      ),
      li: (props) => <MemoLi {...props} />,
      ul: (props) => <MemoUl {...props} />,
      ol: (props) => <MemoOl {...props} />,
    };
  }, [previewImageLink]);

  return (
    <div
      className={cn(
        "prose dark:prose-invert max-w-none break-words",
        className,
      )}
    >
      <Streamdown
        // @ts-ignore patch api, not typed yet
        rehypePluginsBefore={
          isMinimalView
            ? undefined
            : [
                [
                  customStripTagsPlugin,
                  {
                    tagNames: CustomHtmlTags,
                  },
                ],
              ]
        }
        rehypePlugins={
          isMinimalView
            ? undefined
            : [
                [
                  rehypeSanitize,
                  {
                    ...defaultSchema,
                    tagNames: [
                      ...(defaultSchema.tagNames || []),
                      ...CustomHtmlTags,
                      ...mathSanitizeConfig.tagNames,
                    ],
                    attributes: {
                      ...defaultSchema.attributes,
                      workflow: ["path", "id"],
                      "custom-agent": ["path", "id"],
                      ...mathSanitizeConfig.attributes,
                    },
                  },
                ],
              ]
        }
        components={components}
        controls={{ code: !isMinimalView, table: false }}
      >
        {processedChildren}
      </Streamdown>
    </div>
  );
}
