# Support & Community
URL: /community-support
Get help and connect with the Pochi community
***

title: Support & Community
description: Get help and connect with the Pochi community
icon: "Users"
-------------

# **Support & Community**

Our community is a space for Pochi users to connect, learn, and collaborate. We invite you to join us on [Discord](http://discord.gg/tWF66yr8NQ) to engage with fellow developers and the Pochi team.

### **What You'll Find in Our Community**

* **Support and Troubleshooting:** Get help with any issues you encounter and find solutions from experienced users.
* **Feedback and Suggestions:** Share your ideas for new features and help us shape the future of Pochi.
* **Show and Tell:** Showcase the amazing things you're building with Pochi and get inspired by others.
* **Best Practices:** Exchange tips, tricks, and best practices to get the most out of Pochi.

### **Reporting Bugs**

If you encounter a bug or a technical issue, please report it in the relevant channel on our [Discord](http://discord.gg/tWF66yr8NQ). This allows our team to quickly address the problem and provide real-time support. When reporting a bug, please include as much detail as possible, such as screenshots, error messages, and steps to reproduce the issue.

For any other inquiries, you can also reach out to us at [support@getpochi.com](mailto:support@getpochi.com).


# Getting Started
URL: /
Welcome to Pochi - Full-Stack AI Teammate Guide
***

title: "Getting Started"
description: "Welcome to Pochi - Full-Stack AI Teammate Guide"
icon: "Album"
-------------

# **Welcome**

Welcome to the ***Pochi docs*** - your comprehensive guide to using your Full-Stack AI Teammate. Here you'll find resources to help you get started, maximize productivity, and build amazing applications with state-of-the-art AI capabilities.

# **What is Pochi?**

Pochi is an AI agent designed for software development. It operates within your IDE, using a toolkit of commands to execute complex tasks, from code generation to project-wide refactoring.

Pochi's workflow is built on these principles:

* **Agent-Based Workflow**: You assign a task, and Pochi works autonomously to complete it. It can read files, execute commands, and apply changes to your codebase.
* **Flexible & Extensible**: Pochi's functionality is centered around a **Bring Your Own Key (BYOK)** model. This allows you to connect any supported LLM provider, giving you full control over the agent's "brain," your data privacy, and operational costs. No account is required to use the BYOK model.
* **Cloud Services**: For teams that need collaborative features, we offer account-based services like shared task list, group billing. These services are optional and build upon the core functionality.

## **Community & Support**

**Interested in contributing or just engaging with the team?** We welcome your input through our [Discord Community](https://discord.com/invite/tWF66yr8NQ)! Feel free to share feedback, report bugs, and suggest features there!

We're always looking to improve this documentation as well. If you have suggestions or find areas that could be enhanced, please let us know in our Discord channel. Your feedback helps make Pochi better for everyone!

## **Quick Start**

Watch this demo video showcasing the end-to-end experience with Pochi - from extension installation and registration to starting a task and seeing the results:

<div
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1CDxAcO9WGFFC45x5a5HDFdT4u6rtdJrB/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Pochi Demo - End-to-End Experience"
  />
</div>

*This video demonstrates the core agent workflow: installing the extension, assigning a task, and letting Pochi work to produce the result. Note: Registration is optional and only required for cloud-based services.*


# Installation
URL: /installation
Get started with Pochi quickly
***

title: "Installation"
description: "Get started with Pochi quickly"
icon: "Axe"
-----------

# **Installation**

You can get started with Pochi by installing Pochi's VSCode extension.

### **1. Install the VSCode Extension**

Install the Pochi extension from the [VSCode Marketplace](https://marketplace.visualstudio.com/items?itemName=TabbyML.pochi).

1. Open the Extensions view (`Ctrl+Shift+X` or `Cmd+Shift+X`).
2. Search for `Pochi` and click **Install**.

Once installed, the Pochi icon will appear in your Activity Bar.

<Callout title="Getting Started">
  ‚úÖ You should see the Pochi chat window appear in your VSCode editor!
</Callout>

### **2. Configure an LLM Endpoint (BYOK)**

Pochi operates as an AI agent and requires a connection to a Large Language Model (LLM). The primary way to configure this is through the **Bring Your Own Key (BYOK)** model. This approach gives you full control over model choice, costs, and data privacy. No account is necessary to use Pochi with BYOK.

To connect your LLM provider:

1. In VSCode, open Pochi's model selection menu.
2. Click **Manage custom models** from the dropdown ‚Äî this will open VSCode settings with Pochi's configuration highlighted.

<div style={{ display: 'flex' }}>
  <img style={{ margin: '0px 25px' }} src="/images/introduction/manage-custom-model.png" alt="Pochi's Built-in Tools" width="50%" />
</div>

3. Add your API key and configure your model in `pochi.customModelSettings`.

<Callout title="Max tokens & Context window">
  You can configure `maxTokens` and `contextWindow` for each model in custom model settings.

  `maxTokens` is the length of responses and `contextWindow` is how much conversation history the model considers. These values depend on your provider and chosen model ‚Äî check your provider's documentation for the supported limits. As a rule of thumb: smaller values are faster and cheaper, larger values give Pochi more room to reason and remember.
</Callout>

### **3. Assign a Task**

Once the extension is configured, you can assign tasks to the agent. Open the Pochi chat window and describe the task in detail.

For example:

```
Refactor the `ApiService` class in `src/lib/api.ts` to use `axios` instead of `fetch`. Ensure all existing method signatures are preserved and update error handling to use axios-specific error objects.
```

### **Account-Based Features (Optional)**

For teams needing collaborative tools or centralized billing, we offer optional cloud-based services. Creating a Pochi account gives you access to:

* Pochi's managed LLM models.
* Shared task histories and team management.
* Integrations with GitHub and Slack for a collaborative workflow.

To use these features, sign up at [app.getpochi.com](http://app.getpochi.com) and connect your GitHub account in your profile settings.


# MCP
URL: /mcp
Model Context Protocol integration and configuration
***

title: MCP
description: Model Context Protocol integration and configuration
icon: "Spline"
--------------

# **MCP (Model Context Protocol)**

The **Model Context Protocol (MCP)** revolutionizes how Pochi interacts with external services, databases, and APIs. Think of MCP as a universal adapter that connects Pochi to virtually any data source or tool, dramatically expanding what your AI assistant can accomplish.

## **What is MCP?**

Model Context Protocol is an open standard that allows AI applications to securely connect with external resources. It's like having a universal translator that lets Pochi communicate with databases, APIs, cloud services, and custom tools using a common language.

### **Key Concepts**

* **MCP Servers**: Small programs that expose specific functionality to Pochi
* **Tools**: Functions that Pochi can execute through MCP servers
* **Resources**: Read-only data sources like files or database queries
* **Transport**: Communication method (local processes or remote HTTP endpoints)

### **How It Works**

1. You configure MCP servers in Pochi's settings
2. Pochi discovers available tools from each connected server
3. When you chat with Pochi, it can use these tools to accomplish tasks
4. All tool executions require your explicit approval for security

## **Real-World User Stories**

### **üîç Automated PR Review Workflow**

*"Streamline code review process with intelligent GitHub integration"*

**Setup**: Connect GitHub MCP server with repository access

**Result**: Pochi can automatically review PRs, check code quality, suggest improvements, and manage PR lifecycle
**Value**: Faster code review cycles with consistent quality standards

### **üé≠ Component Validation with Playwright**

*"Automatically test and validate UI components across different scenarios"*

**Setup**: Connect Playwright MCP server for automated browser testing

**Result**: Pochi generates components and automatically validates styling, interactions, and responsive behavior through Playwright tests
**Value**: Consistent component quality with automated visual regression testing

### **üìä Database-Driven Development**

*"Query, analyze, and deploy with integrated database operations"*

**Setup**: Connect PostgreSQL and AWS MCP servers
**Result**: Pochi can query your database, analyze performance, and deploy directly to AWS
**Value**: Streamlined development workflow with AI assistance

## **Step-by-Step Setup Guide**

### **Manual VSCode Settings Configuration**

For advanced users who prefer direct configuration:

#### **Step 1: Open VSCode Settings**

1. Open VS Code
2. Press `Cmd/Ctrl + ,` to open Settings
3. Search for "pochi mcp" or navigate to Extensions ‚Üí Pochi

#### **Step 2: Edit settings.json**

Add to your VS Code `settings.json`:

```json
{
  "pochi.mcpServers": {
    "playwright": {
      "command": "npx",
      "args": ["playwright-mcp-server"]
    },
    "context7": {
      "command": "npx",
      "args": ["@upstash/context7-mcp"]
    },
    "github": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-github"],
      "env": {
        "GITHUB_PERSONAL_ACCESS_TOKEN": "your-github-token"
      }
    }
  }
}
```

#### **Step 3: Restart VSCode**

Restart VSCode for the changes to take effect.

## **Configuration Examples**

### **Local MCP Servers (Stdio Transport)**

#### **Filesystem Access**

```json
{
  "filesystem": {
    "command": "npx",
    "args": [
      "-y",
      "@modelcontextprotocol/server-filesystem",
      "/path/to/allowed/files"
    ],
    "env": {
      "HOME": "/Users/yourname"
    }
  }
}
```

#### **Database Connection**

```json
{
  "postgres": {
    "command": "python",
    "args": ["-m", "mcp_postgres", "--connection-string"],
    "env": {
      "DATABASE_URL": "postgresql://user:pass@localhost:5432/db"
    }
  }
}
```

#### **Web Search**

```json
{
  "brave-search": {
    "command": "npx",
    "args": ["-y", "@modelcontextprotocol/server-brave-search"],
    "env": {
      "BRAVE_API_KEY": "your-brave-api-key"
    }
  }
}
```

### **Remote MCP Servers (HTTP Transport)**

#### **Custom API Server**

```json
{
  "my-api": {
    "url": "https://api.mycompany.com/mcp",
    "headers": {
      "Authorization": "Bearer your-api-token",
      "X-API-Version": "v1"
    }
  }
}
```

#### **SSE (Server-Sent Events) Server**

```json
{
  "realtime-data": {
    "url": "https://data.example.com/mcp/sse",
    "headers": {
      "Authorization": "Bearer your-token"
    }
  }
}
```

## **Advanced Configuration**

### **Server Control Options**

```json
{
  "my-server": {
    "command": "node",
    "args": ["server.js"],
    "disabled": false, // Enable/disable entire server
    "disabledTools": ["dangerous_tool"], // Disable specific tools
    "env": {
      "NODE_ENV": "production"
    }
  }
}
```


# Privacy
URL: /privacy
Information about data handling and privacy policy
***

title: Privacy
description: Information about data handling and privacy policy
icon: "Shield"
--------------

# **Privacy**

For comprehensive information about how Pochi handles your data, code, and personal information, please refer to our [Privacy Policy](https://app.getpochi.com/privacy-policy).

Below is a summary of our key privacy principles:

* **Minimal Data Collection:** We only collect the data necessary to provide and improve our service. This includes usage analytics and task-related data, which helps us enhance Pochi's functionality and user experience.
* **Data Security:** We implement industry-standard security measures to protect your data from unauthorized access, alteration, or disclosure.
* **Third-Party Services:** We use trusted third-party services like Stripe for payment processing. We ensure that our partners adhere to strict data protection and privacy standards.


# Rules
URL: /rules
Define coding standards and development guidelines
***

title: Rules
description: Define coding standards and development guidelines
icon: "Ruler"
-------------

# **Rules**

**Rules** tell Pochi about your project's preferences, coding standards, and constraints. It's like giving Pochi a style guide for your codebase.
You can edit your Rule in Pochi Extension Settings page.

<div style={{ display: 'flex', justifyContent: 'center' }}>
  <Image src="/images/core-features/rule/rule-edit.png" alt="alt_text" title="image_tooltip" width="70%" />
</div>

### Setting up Workspace Rules

Create `README.pochi.md` in your project root:

````markdown
# Tabby Project Rules

Tabby is a self-hosted AI coding assistant built with Rust backend and Next.js frontend. Follow these guidelines when contributing to the project.

## Tech Stack

### Backend (Rust)

- **Core**: Rust with Cargo workspace structure
- **Web Framework**: Axum for HTTP APIs
- **Database**: SQLx with PostgreSQL/SQLite
- **AI/ML**: Custom inference engine with CUDA/ROCm/Metal support
- **Search**: Tantivy for code indexing
- **Authentication**: JWT-based auth system
- **Background Jobs**: Tokio-based async job system

### Frontend (Next.js)

- **Framework**: Next.js 13+ with App Router
- **Language**: TypeScript
- **Styling**: Tailwind CSS with Radix UI components
- **State Management**: Zustand + SWR for server state
- **GraphQL**: URQL client with GraphQL Code Generator
- **Forms**: React Hook Form with Zod validation
- **Code Editor**: CodeMirror 6
- **Rich Text**: TipTap editor

### Development Tools

- **Package Manager**: pnpm (required >=9)
- **Build System**: Turbo for monorepo builds
- **Testing**: Vitest for frontend, Rust built-in tests for backend
- **Linting**: ESLint + Prettier for frontend, Clippy for Rust
- **CI/CD**: GitHub Actions

## Coding Standards

### Rust Backend

- Use `snake_case` for variables, functions, and modules
- Use `PascalCase` for structs, enums, and traits
- Prefer `async/await` over manual Future implementations
- Use `anyhow::Result` for error handling in applications
- Use `thiserror` for library error types
- Always add proper error context with `.context()`
- Use `tracing` for logging, not `println!` or `eprintln!`
- Prefer `tokio::spawn` for background tasks
- Use `serde` for serialization with proper derives

### Frontend (TypeScript/React)

- Use `camelCase` for variables and functions
- Use `PascalCase` for components, interfaces, and types
- Prefer functional components with hooks
- Use TypeScript strict mode - always add proper types
- Use `const` over `let` when possible
- Prefer named exports over default exports
- Use Tailwind CSS classes, frontavoid custom CSS when possible
- Use Radix UI components for consistent design
- Always handle loading and error states in components

### File Organization

- **Rust crates**: `/crates/` for open source, `/ee/` for enterprise features
- **Frontend pages**: `/ee/tabby-ui/app/` (Next.js App Router)
- **Frontend components**: `/ee/tabby-ui/components/`
- **Shared utilities**: `/ee/tabby-ui/lib/`
- **GraphQL schemas**: `/ee/tabby-schema/`
- **Database**: `/ee/tabby-db/`

## Testing Guidelines

### Rust Testing

- Write unit tests in the same file using `#[cfg(test)]`
- Use `#[tokio::test]` for async tests
- Use `serial_test` for tests that can't run in parallel
- Skip golden tests during development: `cargo test -- --skip golden`
- Use `temp_testdir` for filesystem tests
- Mock external dependencies appropriately

### Frontend Testing

- Use Vitest for unit and integration tests
- Test files should end with `.test.ts` or `.test.tsx`
- Focus on testing user interactions and business logic
- Use React Testing Library patterns
- Mock GraphQL queries with URQL test utilities

## Development Commands

### Backend Development

```bash
# Build the project
cargo build

# Run with GPU support (choose one)
cargo run --features cuda serve --model TabbyML/StarCoder-1B --device cuda
cargo run --features rocm serve --model TabbyML/StarCoder-1B --device rocm
cargo run serve --model TabbyML/StarCoder-1B --device metal

# Run tests (skip slow golden tests)
cargo test -- --skip golden

# Run specific crate tests
cargo test -p tabby-inference
```

### Frontend Development

```bash
# Install dependencies
pnpm install

# Start development server
pnpm dev

# Build for production
pnpm build

# Run tests
pnpm test

# Lint and format
pnpm lint
pnpm lint:fix

# Generate GraphQL types
pnpm codegen
```

### Monorepo Commands

```bash
# Build all packages
pnpm build

# Run all tests
pnpm test

# Lint all packages
pnpm lint
```

## API & GraphQL Guidelines

### GraphQL Schema

- Use descriptive field names and types
- Add proper documentation to all fields
- Use proper GraphQL scalars (DateTime, URL, etc.)
- Implement proper error handling
- Use DataLoader pattern for N+1 query prevention

### REST API

- Follow OpenAPI 3.0 specification
- Use proper HTTP status codes
- Implement proper error responses
- Add request/response validation
- Use consistent naming conventions

## Database Guidelines

### Migrations

- Always create reversible migrations
- Use descriptive migration names with timestamps
- Test migrations on sample data
- Add proper indexes for query performance
- Use transactions for multi-step migrations

### Queries

- Use prepared statements via SQLx
- Add proper error handling for database operations
- Use connection pooling appropriately
- Implement proper pagination for large datasets

## Security Guidelines

### Authentication & Authorization

- Always validate JWT tokens properly
- Implement proper RBAC (Role-Based Access Control)
- Use secure session management
- Validate all user inputs
- Implement rate limiting for APIs

### Data Protection

- Never log sensitive information
- Use proper encryption for sensitive data
- Implement proper CORS policies
- Validate file uploads thoroughly
- Use HTTPS in production

## Performance Guidelines

### Backend Performance

- Use async/await for I/O operations
- Implement proper connection pooling
- Use background jobs for heavy operations
- Cache frequently accessed data
- Monitor memory usage in long-running processes

### Frontend Performance

- Use React.memo for expensive components
- Implement proper code splitting
- Optimize bundle size with tree shaking
- Use SWR for efficient data fetching
- Implement virtual scrolling for large lists

## AI/ML Specific Guidelines

### Model Integration

- Support multiple inference backends (CUDA, ROCm, Metal, CPU)
- Implement proper model loading and unloading
- Handle model inference errors gracefully
- Use proper tokenization for different models
- Implement model switching without restart

### Code Completion

- Respect user privacy - no data collection without consent
- Implement proper context window management
- Use efficient caching for completions
- Handle streaming responses properly
- Implement proper fallback mechanisms

## Documentation

### Code Documentation

- Add rustdoc comments for all public APIs
- Use TSDoc comments for TypeScript functions
- Include examples in documentation
- Document complex algorithms and business logic
- Keep README files up to date

### API Documentation

- Maintain OpenAPI specifications
- Document GraphQL schema thoroughly
- Provide integration examples
- Keep changelog updated
- Document breaking changes clearly

## Don't Do

### General

- Don't commit secrets or API keys
- Don't use `unwrap()` in production Rust code
- Don't use `any` type in TypeScript
- Don't skip error handling
- Don't commit without running tests
- Don't use `console.log` in production frontend code

### Performance

- Don't block the main thread with heavy computations
- Don't make unnecessary database queries
- Don't load entire datasets without pagination
- Don't use synchronous I/O in async contexts

### Security

- Don't trust user input without validation
- Don't expose internal error details to users
- Don't use weak authentication mechanisms
- Don't store passwords in plain text
- Don't ignore security warnings from dependencies

## Deployment

### Production Requirements

- Use proper environment variables for configuration
- Implement health checks for all services
- Use proper logging and monitoring
- Implement graceful shutdown handling
- Use container orchestration for scaling

### Docker

- Use multi-stage builds for smaller images
- Run as non-root user in containers
- Use proper resource limits
- Implement proper signal handling
- Use official base images when possible
````

### Import Existing Rules

Pochi can import rules from other tools by automatically detecting `.cursorrules` files and importing rules from `.cursor/rules/` directories.
These rules are then converted and merged with your Pochi rules.
For team standards, you can share a `README.pochi.md` file across team repositories to version control your rules and workflows, ensuring consistent coding standards across projects.

### How Pochi uses your rules

On every request, Pochi reads your rules before starting work, automatically following your coding standards and respecting your file organization preferences.
This ensures that all generated code, tests, and documentation adhere to your standards for consistent output.

<Callout title="Getting Started">
  Try a simple `README.pochi.md` file listing your main technologies and basic preferences. You can always add more rules as you discover what works best.
</Callout>


# Tab Completion
URL: /tab-completion
Inline code completion
***

title: Tab Completion
description: Inline code completion
icon: "Code"
------------

# **Tab Completion**

**Tab Completion** is Pochi's in-editor inline code completion feature that provides AI-powered suggestions as you type, helping you write code faster and more efficiently.

Pochi uses a state-of-the-art model that adapts to your coding patterns in real time,
drawing on recent edits, diagnostics, and surrounding context to generate helpful,
relevant completions right in your editor.

<div style={{ display: "flex", justifyContent: "center" }}>
  <Image src="/images/core-features/tab-completion/completion.png" alt="Tab completion showing inline suggestions" title="Inline code completion in action" width="80%" />
</div>

### **Multi-Language Support**

Works across popular programming languages including:

* JavaScript/TypeScript
* Python
* Java
* C/C++
* Go
* Rust
* And many more

## Using Tab Completion

### **Basic Usage**

1. Start typing your code
2. Pochi will show inline suggestions in gray text
3. Press `Tab` to accept the suggestion
4. Press `Escape` to dismiss the suggestion

### **Keyboard Shortcuts**

| Key            | Action                                      |
| -------------- | ------------------------------------------- |
| `Tab`          | Accept the current suggestion               |
| `Escape`       | Dismiss the suggestion                      |
| `Ctrl/Cmd + ‚Üí` | Accept word by word                         |
| `Alt + ]`      | Next suggestion (if multiple available)     |
| `Alt + [`      | Previous suggestion (if multiple available) |

***

**Need help?** Visit our [Community Support](/community-support) page or join our [Discord](https://discord.com/invite/tWF66yr8NQ) for assistance with Tab Completion features.


# Tasks
URL: /tasks
Task management and collaboration features in Pochi
***

title: Tasks
description: Task management and collaboration features in Pochi
icon: "Waypoints"
-----------------

# **Tasks**

**Tasks** represent discrete development objectives Pochi manages from conception to completion. Each task maintains its own context, progress tracking, and collaboration thread within your team's workspace.

Tasks differ from simple prompts by maintaining persistent context, enabling collaborative development, and chain of conversations.

Pochi also keeps persistent state of your tasks, and allows sharing a task if you'd like.

<div style={{ display: "flex", justifyContent: "center" }}>
  <Image src="/images/core-features/tasks/task-sharing.png" alt="alt_text" title="image_tooltip" width="40%" />
</div>

### **Interruptions (Rejection, Editing)**

During Pochi's execution of a task, just like how you work with real engineers, you can also interrupt Pochi's execution any time to modify requirements, reject approaches, adjust priorities, or incorporate team feedback. Interruptions
come naturally just like how you'd talk with a fellow engineer - simply send a message to indicate your intension, then Pochi would pause and reconsiders task planning based on your message. Some
interruption messages could look like

```js
"Change the database from SQLite to PostgreSQL";
"This layout won't work on mobile. Use a card-based design instead";
"Don't use inline styles - let's go with CSS modules";
"Skip the styling for now - let's focus on the API integration first";
```

Changes are immediately reflected in the task thread with updated plans. All thread participants are notified of modifications, while previous work remains accessible in the thread history. Development resumes seamlessly with new requirements while maintaining consistency.

### **Auto-Approve**

**Auto-approve** allows Pochi to execute certain actions autonomously without requiring manual confirmation for each step, streamlining your development workflow.

<div style={{ display: "flex", justifyContent: "center" }}>
  <Image src="/images/core-features/tasks/auto-approve.png" alt="alt_text" title="image_tooltip" width="30%" />
</div>

By default, Pochi asks for your permission (manuel confirming) before taking any action, including reading or writing files.
If you want to allow Pochi to directly take actions, you can set the **Auto Approve** permission for that action.

|     Category    | Operations                                                                                              |
| :-------------: | :------------------------------------------------------------------------------------------------------ |
|     **Read**    | Read the file content Pochi decides to look up for analyzing or completing tasks.                       |
|    **Write**    | Creates new files, edits existing code, generates boilerplate, and writes documentation.                |
|   **Execute**   | Manages dependencies, runs builds, tests, and perform system operations.                                |
|   **Use MCP**   | Interacts with databases, APIs, and other external services to expand its capabilities with MCP server. |
| **Retry Logic** | Automatically retries failed commands, code changes, and installations.                                 |

### **Best Practices**

For most serious development workflows, we recommend starting with:

* Auto-approving **read** access to project files
* Setting a reasonable maximum request limit (suggest to start with at least 3)

This gives Pochi enough freedom to explore your codebase without constant interruptions, while still requiring permission for edits or potentially destructive actions.

As you build more trust in Pochi's capabilities with your specific projects, you can gradually increase the permissions to match your comfort level.

Remember that you can always adjust these settings as your needs change - tighten permissions for critical production work, or loosen them when prototyping and exploring.

### **Advanced Settings - Developer Only, Use at Your Own Risk**

Advanced Settings include Developer Mode that allows you to configure Pochi's behavior with advanced options to customize your development workflow and debugging experience. These settings are experimental and may affect stability.

* **Enable Gemini Custom Tool Calls**: Pochi allows you to integrate custom tools by defining them in a dedicated `tools.ts` file.
  When this feature is enabled, Pochi will automatically detect and utilize the tools you've defined, making them available for use in your development workflow.
  This enables you to extend Pochi's capabilities with your own custom functionalities.

* **Enable Tool: newTask**: The `newTask` tool is a powerful feature that allows Pochi to create new tasks programmatically.
  When this tool is enabled, Pochi can autonomously generate and manage tasks based on your instructions or as part of a larger workflow.
  This is particularly useful for automating repetitive processes or for creating complex, multi-step operations that involve multiple tasks.


# TODO List
URL: /todo-list
Step-by-step execution and task management
***

title: TODO List
description: Step-by-step execution and task management
icon: "Book"
------------

# **TODO List**

Pochi automatically creates and manages ***TODO lists*** to help you track progress on complex tasks.

<div style={{ display: 'flex', justifyContent: 'center' }}>
  <Image src="/images/core-features/todo-list/todo.png" alt="alt_text" title="image_tooltip" width="60%" />
</div>

You can think of it as a shared workspace between you and Pochi. Pochi will clearly show you the step-by-step progress it plans to deliver your tasks, and the real-time progress it's making.


# Tools & Integrations
URL: /tools-integrations
Connect Pochi with your existing development tools
***

title: Tools & Integrations
description: Connect Pochi with your existing development tools
icon: "Wrench"
--------------

# **Agent Toolset & Cloud Integrations**

Pochi's capabilities are divided into its core agent toolset and optional cloud integrations.

## **Core Agent Toolset**

The Pochi agent comes equipped with a set of built-in tools that allow it to interact with your local development environment. These tools are fundamental to its operation and are available by default, regardless of whether you have an account.

Key tools include:

* **File System Access**: Read, write, and modify files.
* **Command Execution**: Run shell commands and scripts.
* **Code Search**: Perform regex-based searches across your codebase.

These tools enable the agent to perform complex, multi-step tasks like refactoring code, adding features, and fixing bugs autonomously. You can review the full list of available tools in the Pochi extension settings.

<div style={{ display: 'flex', justifyContent: 'center' }}>
  <Image src="/images/core-features/tools/built-in-tools.png" alt="Pochi's Built-in Tools" width="50%" />
</div>

## **Cloud Integrations**

For teams and developers who need collaborative features, we offer optional cloud-based integrations. These require a Pochi account and connect the agent to external services.

### **GitHub**

Connecting your GitHub account allows the agent to:

* Clone repositories and understand their full context.
* Create and review pull requests.
* Track and manage issues.
* Handle branch management and resolve merge conflicts.

### **Slack**

Our Slack integration is currently experimental. The goal is to enable seamless collaboration by allowing you to:

* Assign tasks to the Pochi agent directly from Slack channels.
* Receive real-time progress updates in conversation threads.


# Usage
URL: /usage
Model support and credit system information
***

title: Usage
description: Model support and credit system information
icon: "Amphora"
---------------

# **Usage**

Pochi's architecture is designed for flexibility, giving you two primary ways to manage your LLM usage and costs: the **Bring Your Own Key (BYOK)** model and our **Managed Service**.

## **Bring Your Own Key (BYOK)**

This is the default and recommended model for most developers. It provides maximum control and transparency.

* **Cost**: Pochi itself is free to use with this model. You are only responsible for the token costs charged by your selected LLM provider (e.g., OpenAI, Anthropic, etc.).
* **Providers**: You can connect any supported LLM by providing your API key in the extension settings.
* **Billing**: Your LLM provider will bill you directly. Pochi does not add any fees.
* **Benefits**: Full control over model selection, spending, and data privacy. Ideal for developers with existing API subscriptions or those who want to manage their own stack.

## **Managed Service (Optional)**

For users who prefer a simplified setup or want access to our curated model offerings, we provide an optional managed service. This requires a Pochi account.

* **Cost**: Usage is billed through Pochi on a pay-as-you-go basis. We pass through the direct token costs from the LLM providers, plus a small service fee to cover operational expenses.
* **Models**: The managed service includes access to a range of models, categorized by performance and cost.
* **Billing**: We use Stripe for secure payment processing. Upon signing up, you receive a monthly allocation of free credits. After the credits are used, billing occurs based on your token consumption. You can set a monthly spending limit in your profile to control costs.

| Model                | Category | Best For                                                                                          |
| :------------------- | :------- | :------------------------------------------------------------------------------------------------ |
| **Gemini 2.5 Pro**   | Super    | Web development, API integration, adhering to coding standards, and complex component generation. |
| **Claude 4**         | Super    | Code generation, complex reasoning, visual understanding, and full-stack development.             |
| **Kimi-K2**          | Swift    | Balanced performance for most development tasks while maintaining excellent value for money.      |
| **Gemini 2.5 Flash** | Swift    | Rapid prototyping, simpler development tasks, and budget-friendly projects.                       |
| **Qwen3-Coder**      | Swift    | Daily software development with a goal of automation at lower budget.                             |
| **GLM-4.5**          | Swift    | Code automation, basic function calling, and development workflows at budget rates.               |

**Switching Models**: You can change models mid-task based on complexity requirements without losing context.

<div style={{ display: "flex", justifyContent: "center" }}>
  <Image src="/images/account-support/select-model-06-08.png" alt="Select Model" width="70%" />
</div>


# Workflows
URL: /workflows
Automate common development sequences
***

title: Workflows
description: Automate common development sequences
icon: "Workflow"
----------------

# **Workflows**

## What are Workflows?

Workflows are step-by-step automation templates that guide Pochi through complex, multi-step processes. Think of them as detailed recipes that Pochi can follow to complete common development tasks consistently and efficiently.

Key Benefits:

* Consistency - Same process every time, reducing human error
* Efficiency - Automate repetitive multi-step tasks
* Knowledge Sharing - Capture team expertise in reusable templates

## Prerequisites

Before using workflows, you will need:

* VS Code with Pochi extension installed
* Local repository setup: Clone the repository locally to access workflows
* Workflows stored in the `.pochi/workflows/` directory

## Creating Workflows

Reusable patterns in `.pochi/workflows/`:

Example: `.pochi/workflows/create-pr.md`

```
Please help create a PR for the current staging changes, following these guidelines:
- If there are no staging changes but there are uncommitted changes, please stage them first.
- Create a branch name based on the current git diff status.
- Write a meaningful commit message/PR title.
- Use the gh CLI to create a PR.
- When running the push operation, it might be aborted due to a husky pre-push hook. For formatting issues, amend the files and try again. For other issues, try to resolve them as much as possible.
- The base branch for the PR should always be `main`.
- Always push the branch to the remote repository before creating the PR.

When creating PR with markdown description, pay attention to escape backticks, otherwise it will be executed as command substitution in the shell.

```

Example: `.pochi/workflows/review-pr.md`

```
Please help review a PR using the gh CLI:
- Ask user which PR to review (by number, URL, or from list)
- Use `gh pr view` and `gh pr diff` to examine changes
- Analyze code quality, security, tests, and documentation
- Check adherence to project coding standards
- Use askFollowupQuestion to let user choose:
  - "Approve" - Submit approving review
  - "Request Changes" - Submit review with change requests
  - "Comment Only" - Add comments without approval/rejection
  - "More Details" - Get additional information
- Submit review using `gh pr review` with appropriate feedback

```

## How to Use Workflows in VS Code

Once your workflows are set up, using them is straightforward:

1. **Type `/` in VS Code** to trigger the Pochi workflow selector
2. **Select a workflow** from the dropdown menu
3. Pochi executes the workflow automatically

For best efficiency and accuracy, always use the `/` command rather than manually describing the workflow steps to Pochi.

<div
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1p9UeAfkLEOlXBABF4CGub_aqAlAnmbVe/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Pochi Demo - Workflows"
  />
</div>

*This video demonstrates how to use workflows in VS Code*
